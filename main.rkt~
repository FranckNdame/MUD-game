#lang racket
;; Dependencies
(require (prefix-in import: racket/gui))
(require racket/draw)
(require srfi/1)
(require srfi/13)
(require srfi/48)
(require rsound)
(define stream (make-pstream))

;; Include external files

(include "objects.rkt")
(include "gui.rkt")
(include "data.rkt")
(include "location.rkt")



(define menu-sound (rs-read "sounds/menu-sound3.wav"))
(define miss-racket (rs-read "sounds/help-ai.wav"))


;; Instructions
;;------------------------------------------------------------------------------------------------------------------

(define (display-help)
  (stop)
  (play miss-racket)
  (printf "\nINSTRUCTIONS
=================
Welcome to Logic Invation MUD.\n

* GAME OBJECTIVE
  ===============
  The game objective is to activate the nether portal to escape the maze. 
  To be able to open the portal, you must find the Interdimensional Communicator
  in one of the maze rooms.\n\n

* VALID COMMANDS
 ================
          - Enter look, directions or examine room): Get information about the current room.
          - Enter pick, get or pickup [item-name] : Pick the item.
          - Enter drop, put, place or remove [item-name] : Drop the item in your bag on the ground.
          - Enter inventory or bag : Display a list of available items in the bag.
          - Enter help or instructions : Display instructions.
          - Enter quit, exit, quit game or exit game) : Quit the application.\n
          "))

;;------------------------------------------------------------------------------------------------------------------


#|================= GAME LOOP =================|#


(define (gamestart initial-id)
  (let loop ((id initial-id) (description #t))
    (if description
        ;; If there is an available description, shows it on the screen
        (get-location id)
        ;; Else statement. Don't show location(because there isn't any description). Just shows the greater than symbol to incite user to type in text field
        (printf "> "))
    ;; Read input from the keyboard
    (let* ((input (read-line))
           ;; Function contained in the srfi/13 library, tokenize the input into substrings where a space character is found
           (string-tokens (string-tokenize input))
           ;; Creates a list of symbols(not strings) with the input. This is needed to compare the entry with our predefined lists
           (tokens (map string->symbol string-tokens)))
      ;; Decides which action response corresponds to. One of the most important calls in the code
      (let ((response (lookup id tokens)))
        (cond
          ((eq? response 1 )
           ((draws-sprite wake-up (pos 0 0)))))  
        (cond
          ((eq? response 2 )
           (draws-sprite wake-up (pos 0 0))))
        (cond
          ((eq? response 3 )
           (stop)
           (draws-sprite room2 (pos 0 0))          
           (draws-sprite key (pos 370 350))
           ))
        (cond
          ((eq? response 4 )
           (draws-sprite wake-up (pos 0 0))))
        (cond
          ((eq? response 5 )
           (draws-sprite wake-up (pos 0 0))))
        ;(printf "Input: ~a\nTokens: ~a\nResponse: ~a\n" input tokens response)
        (cond ((number? response)
               (loop response #t))
              ;; If response meaning couldn't be found after the lookup function, shows error message
              ((eq? #f response)
               (format #t "Huh? I didn't understand that!\n")
               (loop id #f))
              ;; Response action is look at around the room for directions
              ((eq? response 'look)
               ;; Retrieve possible directions
               (cond
                 ((eq? id 2 )
                  (draws-sprite beam (pos 0 0))))
               (get-directions id)
               
               (loop id #f))
              
              ;; Response action is to pick an item
              ((eq? response 'pick)
               (cond
                 [(eq? id 3) (draws-sprite guard (pos 0 0))])
               ;; Pick up item
               (pick-item id input)
               (loop id #f))
              ;; Response action is to drop an item
              ((eq? response 'drop)
               ;; Drop item
               
               (set! key (read-bitmap "./key.png"))
               (cond

                 [(eq? id 3) (draws-sprite key (pos 370 350))])
                                           
               (drop-item id input)
               (loop id #f))
              ;; Response action is to show inventory
              ((eq? response 'inventory)
               ;; Displays the inventory
               (display-inventory)
               (loop id #f))
              ;; Response action is to display the help file
              ((eq? response 'help)
               ;; Displays Help text on the screen
               (display-help)
               (loop id #f))
              ;; Exit game command
              ((eq? response 'quit)
               ;; Exit the application
               (import:message-box "Bye" "Bye bye" #f '(ok))
               (send frame show #f)
               (stop)
               (exit)))))))



#|=======================================================================|#


#|================= START GAME =================|#

;; Adds the objects to the database before the game starts
(add-objects objectdb)
(draws-sprite startscreen (pos 0 0))
(play menu-sound)
(send (gamestart 1) start 100)

#|==============================================|#


